<html lang="en"><head>

    <head>
    
    <title> Oshinski Lab </title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Little icon at top -->
    <link rel="shortcut icon" href="/img/Banzaitokyo-Medico-Caduceus.ico">
        
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="css/nv.d3.min.css">
    <link rel="stylesheet" type="text/css" href="css/styles.css">      


    <script type="text/javascript" src="js/jquery.min.js"> </script>
    <script type="text/javascript" src="js/bootstrap.js"> </script>
    <script type="text/javascript" src="js/d3.v3.js"> </script>
    <script type="text/javascript" src="js/nv.d3.min.js"> </script>
    <script type="text/javascript" src="js/underscore.js"> </script>
    <script type="text/javascript" src="js/three.min.js"> </script>
    <script type="text/javascript" src="js/detector.js"> </script>
    <script type="text/javascript" src="js/stats.js"> </script>
    <script type="text/javascript" src="js/TrackballControls.js"> </script>

    <!-- Custom CSS -->
    <link href="css/stylish-portfolio.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Highlighting Code -->

    <link rel="stylesheet" href="js/highlight/styles/monokai_sublime.css">

    <style>

        .chart rect 
            fill: steelblue;
        }

        .chart text {
            fill: white;
            font: 10px sans-serif;
            text-anchor: end;
        }

    </style>  
  


    </head>

    <body>


        <script> 

            var camera, scene, renderer, controls,  
            geometry, material, mesh, light1, stats;

            var targetRotationX = 0;
            var targetRotationXOnMouseDown = 0;

            var targetRotationY = 0;
            var targetRotationYOnMouseDown = 0;

            var mouseX = 0;
            var mouseXOnMouseDown = 0;

            var mouseY = 0;
            var mouseYOnMouseDown = 0;          

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;            

            function trim (str) {
                str = str.replace(/^\s+/, '');
                for (var i = str.length - 1; i >= 0; i--) {
                    if (/\S/.test(str.charAt(i))) {
                        str = str.substring(0, i + 1);
                        break;
                    }
                }
                return str;
            }

            // Notes:
            // - STL file format: http://en.wikipedia.org/wiki/STL_(file_format)
            // - 80 byte unused header
            // - All binary STLs are assumed to be little endian, as per wiki doc
            var parseStlBinary = function(stl) {
                var geo = new THREE.Geometry();
                var dv = new DataView(stl, 80); // 80 == unused header
                var isLittleEndian = true;
                var triangles = dv.getUint32(0, isLittleEndian); 

                // console.log('arraybuffer length:  ' + stl.byteLength);
                // console.log('number of triangles: ' + triangles);

                var offset = 4;
                for (var i = 0; i < triangles; i++) {
                    // Get the normal for this triangle
                    var normal = new THREE.Vector3(
                        dv.getFloat32(offset, isLittleEndian),
                        dv.getFloat32(offset+4, isLittleEndian),
                        dv.getFloat32(offset+8, isLittleEndian)
                    );
                    offset += 12;

                    // Get all 3 vertices for this triangle
                    for (var j = 0; j < 3; j++) {
                        geo.vertices.push(
                            new THREE.Vector3(
                                dv.getFloat32(offset, isLittleEndian),
                                dv.getFloat32(offset+4, isLittleEndian),
                                dv.getFloat32(offset+8, isLittleEndian)
                            )
                        );
                        offset += 12
                    }

                    // there's also a Uint16 "attribute byte count" that we
                    // don't need, it should always be zero.
                    offset += 2;   

                    // Create a new face for from the vertices and the normal             
                    geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
                }

                // The binary STL I'm testing with seems to have all
                // zeroes for the normals, unlike its ASCII counterpart.
                // We can use three.js to compute the normals for us, though,
                // once we've assembled our geometry. This is a relatively 
                // expensive operation, but only needs to be done once.
                geo.computeFaceNormals();

                mesh = new THREE.Mesh( 
                    geo,
                    // new THREE.MeshNormalMaterial({
                    //     overdraw:true
                    // }
                    new THREE.MeshLambertMaterial({
                        overdraw:true,
                        color: 0xaa0000,
                        shading: THREE.FlatShading
                    }
                ));
                scene.add(mesh);

                // Color: http://threejs.org/examples/webgl_geometry_colors.html                

                stl = null;
            };  


            init();
            animate();

            function init() {

                //Detector.addGetWebGLMessage();

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 10000, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.z = 110;
                camera.position.y = 0;
                camera.position.x = 0;
                scene.add( camera );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 0; 
                directionalLight.position.y = 0; 
                directionalLight.position.z = 1; 
                directionalLight.position.normalize();
                scene.add( directionalLight );


                var directionalLight2 = new THREE.DirectionalLight( 0xffffff );
                directionalLight2.position.x = 0; 
                directionalLight2.position.y = 0; 
                directionalLight2.position.z = -1; 
                directionalLight2.position.normalize();
                scene.add( directionalLight2 );

                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if ( xhr.readyState == 4 ) {
                        if ( xhr.status == 200 || xhr.status == 0 ) {
                            var rep = xhr.response; // || xhr.mozResponseArrayBuffer;
                            console.log(rep);
                            parseStlBinary(rep);
                            //parseStl(xhr.responseText);
                            mesh.rotation.x = 1.57;
                            mesh.rotation.z = .25;
                            console.log('done parsing');
                        }
                    }
                }
                xhr.onerror = function(e) {
                    console.log(e);
                }
                
                xhr.open( "GET", '/stl/cryo013_full.stl', true );
                xhr.responseType = "arraybuffer";
                //xhr.setRequestHeader("Accept","text/plain");
                //xhr.setRequestHeader("Content-Type","text/plain");
                //xhr.setRequestHeader('charset', 'x-user-defined');
                xhr.send( null );

                renderer = new THREE.WebGLRenderer( {alpha: true} ); //new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( 0xffffff, 0 );

                document.body.appendChild( renderer.domElement );

                // controls = new THREE.TrackballControls( camera, renderer.domElement );
                // controls.minDistance = 50;
                // controls.maxDistance = 100;                

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                document.body.appendChild(stats.domElement);

                renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
                renderer.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
                renderer.domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }            

            function onDocumentMouseDown(event) {

                event.preventDefault();

                renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
                renderer.domElement.addEventListener( 'mouseout', onDocumentMouseOut, false );

                mouseXOnMouseDown = event.clientX - windowHalfX;
                mouseYOnMouseDown = event.clientY - windowHalfY;
                targetRotationXOnMouseDown = targetRotationX;
                targetRotationYOnMouseDown = targetRotationY;

            }

            function onDocumentMouseMove(event) {

                mouseX = event.clientX - windowHalfX;
                mouseY = event.clientY - windowHalfY;

                targetRotationX = targetRotationXOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
                targetRotationY = targetRotationYOnMouseDown + (mouseY - mouseYOnMouseDown) * 0.02;

            }

            function onDocumentMouseUp(event) {

                renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

            }

            function onDocumentMouseOut(event) {

                renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

            }

            function onDocumentTouchStart(event) {

                if (event.touches.length == 1) {

                    event.preventDefault();

                    mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
                    targetRotationXOnMouseDown = targetRotationX;

                    mouseYOnMouseDown = event.touches[ 0 ].pageX - windowHalfY;
                    targetRotationYOnMouseDown = targetRotationY;


                }

            }

            function onDocumentTouchMove(event) {

                if (event.touches.length == 1) {

                    event.preventDefault();

                    mouseX = event.touches[ 0 ].pageX - windowHalfX;
                    mouseY = event.touches[ 0 ].pageY - windowHalfY;
                    targetRotationX = targetRotationXOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
                    targetRotationY = targetRotationYOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.05;

                }

            }            

            function animate() {

                // note: three.js includes requestAnimationFrame shim
                requestAnimationFrame( animate );
                render();
                // controls.update();
                stats.update();

            }

            function render() {

                mesh.rotation.z += ( targetRotationX - mesh.rotation.z ) * 0.05;
                // mesh.rotation.y += ( targetRotationY - mesh.rotation.y ) * 0.05;

                renderer.render( scene, camera );

            }

        


        </script>

    </body>

</html>

<html lang="en"><head>

    <head>
    
    <title> Oshinski Lab </title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Little icon at top -->
    <link rel="shortcut icon" href="/img/Banzaitokyo-Medico-Caduceus.ico">
        
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../css/nv.d3.min.css">
    <link rel="stylesheet" type="text/css" href="../css/styles.css">      


    <script type="text/javascript" src="../js/jquery.min.js"> </script>
    <script type="text/javascript" src="../js/bootstrap.js"> </script>
    <script type="text/javascript" src="../js/d3.v3.js"> </script>
    <script type="text/javascript" src="../js/nv.d3.min.js"> </script>
    <script type="text/javascript" src="../js/underscore.js"> </script>
    <script type="text/javascript" src="../js/three.min.js"> </script>
    <script type="text/javascript" src="../js/detector.js"> </script>
    <script type="text/javascript" src="../js/stats.js"> </script>
    <script type="text/javascript" src="../js/lut.js"> </script>
    <script type="text/javascript" src="../js/TrackballControls.js"> </script>

    <!-- Custom CSS -->
    <link href="../css/stylish-portfolio.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Highlighting Code -->

    <link rel="stylesheet" href="../js/highlight/styles/monokai_sublime.css">

    </head>

    <body>
        <script> 

            var camera, scene, renderer, controls, lut, geo,
            material, mesh, light1, stats;

            var cdata = '';

            var colorMap,numberOfColors;

            var targetRotationX = 0;
            var targetRotationXOnMouseDown = 0;

            var targetRotationY = 0;
            var targetRotationYOnMouseDown = 0;

            var mouseX = 0;
            var mouseXOnMouseDown = 0;

            var mouseY = 0;
            var mouseYOnMouseDown = 0;          

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;            

            function trim (str) {
                str = str.replace(/^\s+/, '');
                for (var i = str.length - 1; i >= 0; i--) {
                    if (/\S/.test(str.charAt(i))) {
                        str = str.substring(0, i + 1);
                        break;
                    }
                }
                return str;
            }


            // Notes:
            // - STL file format: http://en.wikipedia.org/wiki/STL_(file_format)
            // - 80 byte unused header
            // - All binary STLs are assumed to be little endian, as per wiki doc
            var parseStlBinary = function(stl) {
                geo = new THREE.BufferGeometry();
                var dv = new DataView(stl, 80); // 80 == unused header
                var isLittleEndian = true;
                var triangles = dv.getUint32(0, isLittleEndian); 

                var vertices = new Float32Array( triangles * 9 );

                var offset = 4;
                var cnt =0;


                console.log("loadSTL")
                if (cdata.length == 0)
                {
                    setTimeout(function(){ console.log("Wait") }, 1000);
                }

                for (var i = 0; i < triangles; i++) {
                    // Get the normal for this triangle
                    var normal = new THREE.Vector3(
                        dv.getFloat32(offset, isLittleEndian),
                        dv.getFloat32(offset+4, isLittleEndian),
                        dv.getFloat32(offset+8, isLittleEndian)
                    );
                    offset += 12;

                    // Get all 3 vertices for this triangle
                    for (var j = 0; j < 3; j++) {


                        vertices[ cnt*3 + 0] = dv.getFloat32(offset, isLittleEndian)
                        vertices[ cnt*3 + 1] = dv.getFloat32(offset+4, isLittleEndian)
                        vertices[ cnt*3 + 2] = dv.getFloat32(offset+8, isLittleEndian)

                        offset += 12
                        cnt+=1
                    }

                    // there's also a Uint16 "attribute byte count" that we
                    // don't need, it should always be zero.
                    offset += 2;   

                    // Create a new face for from the vertices and the normal             

                }

                geo.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );                

                geo.computeVertexNormals();
                geo.normalizeNormals();

                var lutColors = [];

                console.log("TESTING12",cdata.length)
                console.log(vertices.length)

                lut = new THREE.Lut( colorMap, numberOfColors );

                lut.setMax( 2000 );
                lut.setMin( 0 );

                for ( var i = 0; i < cdata.length; i++ ) {

                    color = lut.getColor( parseFloat(cdata[i])*3000 );

                    if ( color == undefined ) {

                        console.log( "ERROR: " + colorValue );

                    } else {

                        lutColors[ 3 * i     ] = color.r;
                        lutColors[ 3 * i + 1 ] = color.g;
                        lutColors[ 3 * i + 2 ] = color.b;

                    }
                }

                material = new THREE.MeshLambertMaterial( {

                        side: THREE.DoubleSide,
                        color: 0xF5F5F5,
                        vertexColors: THREE.VertexColors

                } );

                geo.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( lutColors ), 3 ) );
                

                console.log(material)
                console.log(geo)

                mesh = new THREE.Mesh( geo, material  );

                scene.add(mesh);

                // Color: http://threejs.org/examples/webgl_geometry_colors.html                

                stl = null;
            };  

            function loadSTL() {

                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if ( xhr.readyState == 4 ) {
                        if ( xhr.status == 200 || xhr.status == 0 ) {
                            var rep = xhr.response; // || xhr.mozResponseArrayBuffer;
                            parseStlBinary(rep);
                            mesh.rotation.x = 1.57;
                            mesh.rotation.z = .25;
                            console.log('Done parsing');
                        }
                    }
                }
                xhr.onerror = function(e) {
                    console.log(e);
                }
                
                xhr.open( "GET", '/stl/cryo013_full.stl', true );
                xhr.responseType = "arraybuffer";
                //xhr.setRequestHeader("Accept","text/plain");
                //xhr.setRequestHeader("Content-Type","text/plain");
                //xhr.setRequestHeader('charset', 'x-user-defined');
                xhr.send( null );

            }

            function loadCData() {

                var client = new XMLHttpRequest();
                client.onreadystatechange = function() {
                    if ( client.readyState == 4 ) {
                        if ( client.status == 200 || client.status == 0 ) {
                            var rep = client.response; // || xhr.mozResponseArrayBuffer;
                            console.log(rep.length)

                            cdata = rep.split(",")
                        }
                    }                    
                }

                // false makes it a synchronous call
                client.open('GET', 'cdata.txt', false);
                client.send( null );                   

            }


            init();
            animate();

            function init() {

                Detector.addGetWebGLMessage();

                scene = new THREE.Scene();

                colorMap = 'rainbow';
                numberOfColors = 512;                

                camera = new THREE.PerspectiveCamera( 10000, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.z = 85;
                camera.position.y = -5;
                camera.position.x = 0;
                scene.add( camera );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 0; 
                directionalLight.position.y = 0; 
                directionalLight.position.z = 1; 
                directionalLight.position.normalize();
                scene.add( directionalLight );


                var directionalLight2 = new THREE.DirectionalLight( 0xffffff );
                directionalLight2.position.x = 0; 
                directionalLight2.position.y = 0; 
                directionalLight2.position.z = -1; 
                directionalLight2.position.normalize();
                scene.add( directionalLight2 );

                loadCData()
                loadSTL()

                renderer = new THREE.WebGLRenderer( {alpha: true} ); //new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( 0xffffff, 0 );

                document.body.appendChild( renderer.domElement );

                // controls = new THREE.TrackballControls( camera, renderer.domElement );
                // controls.minDistance = 50;
                // controls.maxDistance = 100;                

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                // document.body.appendChild(stats.domElement);

                renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
                renderer.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
                renderer.domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }            

            function onDocumentMouseDown(event) {

                event.preventDefault();

                renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
                renderer.domElement.addEventListener( 'mouseout', onDocumentMouseOut, false );

                mouseXOnMouseDown = event.clientX - windowHalfX; 
               mouseYOnMouseDown = event.clientY - windowHalfY;
                targetRotationXOnMouseDown = targetRotationX;
                targetRotationYOnMouseDown = targetRotationY;

            }

            function onDocumentMouseMove(event) {

                mouseX = event.clientX - windowHalfX;
                mouseY = event.clientY - windowHalfY;

                targetRotationX = targetRotationXOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
                targetRotationY = targetRotationYOnMouseDown + (mouseY - mouseYOnMouseDown) * 0.02;

            }

            function onDocumentMouseUp(event) {

                renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

            
}
            function onDocumentMouseOut(event) {

                renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

            }

            function onDocumentTouchStart(event) {

                if (event.touches.length == 1) {

                    event.preventDefault();

                    mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
                    targetRotationXOnMouseDown = targetRotationX;

                    mouseYOnMouseDown = event.touches[ 0 ].pageX - windowHalfY;
                    targetRotationYOnMouseDown = targetRotationY;


                }

            }

            function onDocumentTouchMove(event) {

                if (event.touches.length == 1) {

                    event.preventDefault();

                    mouseX = event.touches[ 0 ].pageX - windowHalfX;
                    mouseY = event.touches[ 0 ].pageY - windowHalfY;
                    targetRotationX = targetRotationXOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
                    targetRotationY = targetRotationYOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.05;

                }

            }            

            function animate() {

                // note: three.js includes requestAnimationFrame shim
                requestAnimationFrame( animate );
                render();
                // controls.update();
                stats.update();

            }

            function render() {

                mesh.rotation.z += ( targetRotationX - mesh.rotation.z ) * 0.05;
                // mesh.rotation.y += ( targetRotationY - mesh.rotation.y ) * 0.05;

                renderer.render( scene, camera );

            }

        


        </script>

    <br><br><br><br><br><br>

    </body>

</html>

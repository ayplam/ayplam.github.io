---
layout: testing
---

<section class="content">

	<section id="about" class="background">
		<div id="decrypt" position="fixed" class="container">
		   <div class="row">
		      	<div class="col-md-6" style="font-size:50px;">
		         <strong>  STL Testing </strong>
		      </div>
		   </div>

		   <canvas width="400" height="10"></canvas>

		</div>

		<script> 


            var camera, scene, renderer, controls,  
            geometry, material, mesh, light1, stats;

			var targetRotationX = 0;
			var targetRotationXOnMouseDown = 0;

			var targetRotationY = 0;
			var targetRotationYOnMouseDown = 0;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var mouseY = 0;
			var mouseYOnMouseDown = 0;			

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;            

            function trim (str) {
                str = str.replace(/^\s+/, '');
                for (var i = str.length - 1; i >= 0; i--) {
                    if (/\S/.test(str.charAt(i))) {
                        str = str.substring(0, i + 1);
                        break;
                    }
                }
                return str;
            }

            // Notes:
            // - STL file format: http://en.wikipedia.org/wiki/STL_(file_format)
            // - 80 byte unused header
            // - All binary STLs are assumed to be little endian, as per wiki doc
            var parseStlBinary = function(stl) {
                var geo = new THREE.Geometry();
                var dv = new DataView(stl, 80); // 80 == unused header
                var isLittleEndian = true;
                var triangles = dv.getUint32(0, isLittleEndian); 

                // console.log('arraybuffer length:  ' + stl.byteLength);
                // console.log('number of triangles: ' + triangles);

                var offset = 4;
                for (var i = 0; i < triangles; i++) {
                    // Get the normal for this triangle
                    var normal = new THREE.Vector3(
                        dv.getFloat32(offset, isLittleEndian),
                        dv.getFloat32(offset+4, isLittleEndian),
                        dv.getFloat32(offset+8, isLittleEndian)
                    );
                    offset += 12;

                    // Get all 3 vertices for this triangle
                    for (var j = 0; j < 3; j++) {
                        geo.vertices.push(
                            new THREE.Vector3(
                                dv.getFloat32(offset, isLittleEndian),
                                dv.getFloat32(offset+4, isLittleEndian),
                                dv.getFloat32(offset+8, isLittleEndian)
                            )
                        );
                        offset += 12
                    }

                    // there's also a Uint16 "attribute byte count" that we
                    // don't need, it should always be zero.
                    offset += 2;   

                    // Create a new face for from the vertices and the normal             
                    geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
                }

                // The binary STL I'm testing with seems to have all
                // zeroes for the normals, unlike its ASCII counterpart.
                // We can use three.js to compute the normals for us, though,
                // once we've assembled our geometry. This is a relatively 
                // expensive operation, but only needs to be done once.
                geo.computeFaceNormals();

                mesh = new THREE.Mesh( 
                    geo,
                    // new THREE.MeshNormalMaterial({
                    //     overdraw:true
                    // }
                    new THREE.MeshLambertMaterial({
                        overdraw:true,
                        color: 0xaa0000,
                        shading: THREE.FlatShading
                    }
                ));
                scene.add(mesh);

                stl = null;
            };  


            init();
            animate();

            function init() {

                //Detector.addGetWebGLMessage();

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 10000, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.z = 100;
                camera.position.y = 0;
                camera.position.x = 0;
                scene.add( camera );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 0; 
                directionalLight.position.y = 0; 
                directionalLight.position.z = 1; 
                directionalLight.position.normalize();
                scene.add( directionalLight );


                var directionalLight2 = new THREE.DirectionalLight( 0xffffff );
                directionalLight2.position.x = 0; 
                directionalLight2.position.y = 0; 
                directionalLight2.position.z = -1; 
                directionalLight2.position.normalize();
                scene.add( directionalLight2 );

                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if ( xhr.readyState == 4 ) {
                        if ( xhr.status == 200 || xhr.status == 0 ) {
                            var rep = xhr.response; // || xhr.mozResponseArrayBuffer;
                            console.log(rep);
                            parseStlBinary(rep);
                            //parseStl(xhr.responseText);
                            mesh.rotation.x = 1.57;
                            mesh.rotation.z = .25;
                            console.log('done parsing');
                        }
                    }
                }
                xhr.onerror = function(e) {
                    console.log(e);
                }
                
                xhr.open( "GET", 'cryo013_full.stl', true );
                xhr.responseType = "arraybuffer";
                //xhr.setRequestHeader("Accept","text/plain");
                //xhr.setRequestHeader("Content-Type","text/plain");
                //xhr.setRequestHeader('charset', 'x-user-defined');
                xhr.send( null );

                renderer = new THREE.WebGLRenderer( {alpha: true} ); //new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor( 0xffffff, 0 );

                document.body.appendChild( renderer.domElement );

				// controls = new THREE.TrackballControls( camera, renderer.domElement );
				// controls.minDistance = 50;
				// controls.maxDistance = 100;                

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                document.body.appendChild(stats.domElement);

				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
				renderer.domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );


            }

			function onDocumentMouseDown(event) {

				event.preventDefault();

				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
				renderer.domElement.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationXOnMouseDown = targetRotationX;
				targetRotationYOnMouseDown = targetRotationY;

			}

			function onDocumentMouseMove(event) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

				targetRotationX = targetRotationXOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
				targetRotationY = targetRotationYOnMouseDown + (mouseY - mouseYOnMouseDown) * 0.02;

			}

			function onDocumentMouseUp(event) {

				renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentMouseOut(event) {

				renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentTouchStart(event) {

				if (event.touches.length == 1) {

					event.preventDefault();

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationXOnMouseDown = targetRotationX;

					mouseYOnMouseDown = event.touches[ 0 ].pageX - windowHalfY;
					targetRotationYOnMouseDown = targetRotationY;


				}

			}

			function onDocumentTouchMove(event) {

				if (event.touches.length == 1) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
					targetRotationX = targetRotationXOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
					targetRotationY = targetRotationYOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.05;

				}

			}            

            function animate() {

                // note: three.js includes requestAnimationFrame shim
                requestAnimationFrame( animate );
                render();
                // controls.update();
                stats.update();

            }

            function render() {

            	mesh.rotation.z += ( targetRotationX - mesh.rotation.z ) * 0.05;
            	console.log(mesh.rotation.z)
            	// mesh.rotation.y += ( targetRotationY - mesh.rotation.y ) * 0.05;

                renderer.render( scene, camera );

            }

        


		</script>




	</section>




</section>
